<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>一本不成器的笔记罢了</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="一本不成器的笔记罢了">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Just a Chapter</a></li><li class="chapter-item expanded "><a href="floating_point_division.html"><strong aria-hidden="true">2.</strong> 浮点数除法优化</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Rust核心概念</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="raii_and_resource_management.html"><strong aria-hidden="true">3.1.</strong> RAII与资源管理</a></li><li class="chapter-item "><a href="zero_cost_abstration.html"><strong aria-hidden="true">3.2.</strong> 零成本抽象</a></li><li class="chapter-item "><a href="ownership_and_borrowing.html"><strong aria-hidden="true">3.3.</strong> 所有权与借用</a></li><li class="chapter-item "><a href="result_or_panic.html"><strong aria-hidden="true">3.4.</strong> Result与Panic</a></li></ol></li><li class="chapter-item expanded "><a href="tcp_ip_prototols.html"><strong aria-hidden="true">4.</strong> TCP/IP协议栈</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hypertext_transfer_protocol.html"><strong aria-hidden="true">4.1.</strong> HTTP协议</a></li></ol></li><li class="chapter-item expanded "><a href="systemd.html"><strong aria-hidden="true">5.</strong> systemd</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">一本不成器的笔记罢了</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/mapkts/keynote" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<p>Just an exmaple chapter. Nothing serious.</p>
<h2 id="section-1"><a class="header" href="#section-1">Section 1</a></h2>
<p>Hello Rust!</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = &quot;Hello, Rust!&quot;;

    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>\[ \mu = \frac{1}{N} \sum_{i=0} x_i \]</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
)

func main() {}
</code></pre>
<h2 id="section-2"><a class="header" href="#section-2">Section 2</a></h2>
<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>
<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.</p>
<h1 id="浮点数除法优化"><a class="header" href="#浮点数除法优化">浮点数除法优化</a></h1>
<blockquote>
<p>在计算密集型的应用中，优化除法运算是有一定必要的，因为编译器可能不如你想象的那么聪明</p>
</blockquote>
<p>最近在跟着<a href="https://www.pbr-book.org/3ed-2018/contents"><code>PBRT</code></a>这本书写一个简单的离线物理渲染器，在对光线和实体对象（如球体）求交时，需要频繁地做除法运算将一个空间向量单位化。大家都知道，CPU的除法指令要比乘法指令慢得多，比如对AMD最新的Zen 3架构CPU（Ryzen 5000系列）的测试显示<sup class="footnote-reference"><a href="#1">1</a></sup>，一次x87浮点除法运算需要的时钟周期大约是乘法运算所需时钟周期的6倍（见下图）。</p>
<table><thead><tr><th align="center">x87浮点指令</th><th align="center">延迟</th><th align="center">1 / 吞吐量</th></tr></thead><tbody>
<tr><td align="center">FMUL</td><td align="center">6-7</td><td align="center">1</td></tr>
<tr><td align="center">FDIV</td><td align="center">15</td><td align="center">6</td></tr>
</tbody></table>
<p>在实现向量对标量的除法时，书上建议先求出被除标量的倒数，然后再将向量的每一元素都乘以这个倒数，来得出单位向量。问题来了，对于这种简单而直接的优化方式，现代编译器不应该会自动优化吗？这种手动优化是否有必要呢？</p>
<p>为避免不必要的过度优化，我们可以写两个基准测试对比手动优化版和无修改版的性能表现，来确定编译器是否会帮我们做相应优化。</p>
<h2 id="测试过程"><a class="header" href="#测试过程">测试过程</a></h2>
<p>首先我们按上面所说的方法来实现两种不同的向量对标量的除法运算，这里我们选择三维向量用于测试。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone)]
pub struct V1(pub f32, pub f32, pub f32);

// 求倒后乘法
impl core::ops::Div&lt;f32&gt; for V1 {
    type Output = Self;

    #[inline]
    fn div(self, rhs: f32) -&gt; Self {
        // 将三次除法替换成一次除法和三次乘法
        let inv = 1. / rhs;
        Self(self.0 * inv, self.1 * inv, self.2 * inv)
    }
}

#[derive(Copy, Clone)]
pub struct V2(pub f32, pub f32, pub f32);

// 直接相除法
impl core::ops::Div&lt;f32&gt; for V2 {
    type Output = Self;

    #[inline]
    fn div(self, rhs: f32) -&gt; Self {
        // 直接进行三次除法
        Self(self.0 / rhs, self.1 / rhs, self.2 / rhs)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>下面给出的是测试用例，为简化代码我们这里直接使用Rust的bench test模块。为防止出现下溢或上溢的情况，这里选择在bencher外初始化一个向量，向量的每个元素的初始值都设为<code>f32::MAX</code>,然后每次循环都除以一个非常小的增量1.01。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]
<span class="boring">fn main() {
</span>extern crate test;

#[cfg(test)]
mod bench {
    use super::*;
    use test::Bencher;

    #[bench]
    fn test_cached_div(bencher: &amp;mut Bencher) {
       let mut x = V1(f32::MAX, f32::MAX, f32::MAX);
       bencher.iter(|| {
           for _ in 0..10000 {
               x = x / 1.01;
           }
       });
    }

    #[bench]
    fn test_direct_div(bencher: &amp;mut Bencher) {
       let mut x = V2(f32::MAX, f32::MAX, f32::MAX);
       bencher.iter(|| {
           for _ in 0..10000 {
               x = x / 1.01;
           }
       });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在我的笔记本（CPU型号为AMD Ryzen 7 4800U）上运行的测试结果如下：</p>
<pre><code class="language-bash">test bench::test_cached_div ... bench:      15,020 ns/iter (+/- 963)
test bench::test_direct_div ... bench:      47,348 ns/iter (+/- 578)
</code></pre>
<p>从测试结果我们可以看到，直接除法比优化的除法慢将近3倍，说明编译器并没有对除法运算做优化。</p>
<h2 id="原因分析"><a class="header" href="#原因分析">原因分析</a></h2>
<p>事实上，编译器之所以没有进行上面所说的除法优化，是由于这种优化很可能会破坏程序的正确性（相对于性能而言，正确性是编译器在优化代码时首先要保证的）。IEEE浮点数标准要求，对于所有的\( x \), 有</p>
<p>\[ \frac{1}{x} \cdot x = 1 \]</p>
<p>由于浮点数求倒数有可能发生精度丢失，我们如果将计算的\( \frac{1}{x} \)保存起来再乘\( x \)的话，并不能保证结果还是1。编译器为了符合IEEE浮点数标准的要求，被限制执行这类的转换。也就是说，如果我们要打破这一保证以换取更高性能表现的话，需要自己手动做这方面的转换。</p>
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://agner.org/optimize/instruction_tables.pdf">Agner Fog指令测试表</a></p>
</div>
<h1 id="raii与资源管理"><a class="header" href="#raii与资源管理">RAII与资源管理</a></h1>
<p>如果要给计算机史上最糟糕的技术词汇命名弄一个排行榜的话，由C++之父创造的RAII<sup class="footnote-reference"><a href="#1">1</a></sup>肯定榜上有名。首先是发音问题，到底该念Ray? Rai? 还是R.A.I.I呢？没有人知道。其次，作为一种有关资源获取和释放的管理机制，其全称<strong>资源获取即初始化</strong>(Resource Acquisition is Initialization)只描述了RAII机制关于资源初始化的部分，而事实上更为关键的<strong>资源释放即析构</strong>(Resource Release is Destruction)却选择性地被忽略了，导致很多像我这样的小白刚接触的时候就被其高大上唬住了，不敢知其所以然。</p>
<p>为了更好地理解RAII机制，我们先来聊聊什么是资源。资源是一个很宽泛的概念，在不同的语境下有不同的含义，我们上面提到的资源实际上是指操作系统提供给应用程序的内存、文件句柄、socket和锁等数量有限的东西，这里为方便理解我们从资源管理方式角度将其分为以下三类：</p>
<p><img src="./img/system_resources.png" alt="system resources" /></p>
<p>第一类是静态分配的内存，比如栈内存、全局变量区内存和静态变量区内存等。这类内存该分配多少，以及怎么分配和释放（程序运行一开始由系统分配，程序结束时才会被释放）是由编译器在编译和链接阶段确定的，不需要用户手动管理。由于Rust的内存模型目前还未稳定下来<sup class="footnote-reference"><a href="#2">2</a></sup>，这里也就不具体展开来说了。</p>
<p>第二类是系统在运行时根据程序的需要动态分配的堆内存等。这类内存由程序自行申请，用完后需由程序自行释放，否则会导致内存泄漏的问题。
这类内存一般比其他内存大且无序，管理起来很麻烦，因此Go、Java等比较偏应用层的静态类型语言和绝大部分动态类型语言都选择引入GC来进行自动管理，让开发者可以更专注于应用逻辑。GC不好的地方在于会带来运行时的性能开销和STW<sup class="footnote-reference"><a href="#3">3</a></sup>的问题，对于C++、Rust等比较偏底层且注重性能的语言来说是完全不可接受的，因此都选择引入RAII机制来进行资源管理。虽然GC和RAII都能自动管理堆上内存，减轻开发者的心智负担，但是两者的思想是很不一样的，这个我们留后面再讲。</p>
<p>第三类是诸如文件句柄/描述符、锁、socket等从操作系统获取的资源，这类资源必须由用户显示地关闭才能被操作系统回收，单单清除内存里的资源持有对象仍然可能会导致内存泄漏（甚至可能导致更严重的影响程序逻辑的错误，如忘记释放锁而导致死锁问题）。GC的引入可以让开发者从内存管理中解脱出来，但对于这类资源的管理就无能为力了。</p>
<p>RAII要解决的问题，就是让第三类资源和第二类资源的处理方式统一起来，具体来说就是：</p>
<ul>
<li>Resource Acquisition is Initialization: <strong>在持有对象被初始化时完成资源的分配</strong></li>
<li>Resource Release is Destruction: <strong>在持有对象被析构时完成资源的释放</strong></li>
</ul>
<p>通过这种将资源的生命周期和持有对象的生命周期强绑定的方式，RAII保证了<strong>只要对象能被正确地析构，就不会出现资源泄漏的问题</strong>。同时，作为一种比GC更通用的资源管理机制，RAII还有另一个不可忽视的特性，那就是可以很好地保证代码的异常安全性。例如在下面Non-RAII的代码中（我们这里假设Rust没有RAII机制），一个异常如果发生在锁申请和锁释放之间的话，释放锁的语句得不到执行，因此会导致资源泄漏和死锁双重问题的出现。</p>
<pre><pre class="playground"><code class="language-rust no_run">// non_raii.rs
<span class="boring">#![feature(mutex_unlock)]
</span><span class="boring">use std::sync::Mutex;
</span>
fn main() {
    let mutex = Mutex::new(0); // 构造、申请一个Mutex对象

    let mut guard = mutex.lock().unwrap(); // 上锁并获取MutexGuard

    // 这里出现了异常！（这里的异常可以理解为Java、C++的异常，或者Rust的Error和panic!）

    Mutex::unlock(guard); // 因为出现了异常，这里的解锁语句不会再执行了
}
</code></pre></pre>
<p>对于像Rust这样支持RAII的语言，即使发生了异常，Mutex也会被在栈展开<sup class="footnote-reference"><a href="#4">4</a></sup>的过程中被析构，保证了异常安全。</p>
<pre><pre class="playground"><code class="language-rust no_run">// raii.rs
<span class="boring">use std::sync::Mutex;
</span>
fn main() {
    let mutex = Mutex::new(0);

    let mut guard = mutex.lock().unwrap();

    // 这里出现了异常！

    // 当离开作用域时，mutex会被自动析构 (不管是否抛出了异常)
}
</code></pre></pre>
<p>相对的，对于GC语言来说，为了保证资源管理的异常安全，通常的办法是提供一个不管是否发生异常都会执行的语句，来确保资源在出现异常的情况下也能被正确地释放，比如Java中的finally语句和Golang中的defer语句。以下是一个在Java中用finally来释放socket的例子：</p>
<pre><code class="language-java">// socket.java

void main() {
    Socket socket;
    try {
        socket = new Socket();
        access(socket);
    } finally {
        socket.close(); // 不管有没有发生异常这里都会执行
    }
}
</code></pre>
<p>可见对于GC语言来说，为了保证第三类资源的内存安全和异常安全，开发者需要在(1)特定的语句中(2)显式地释放资源，但是第二类资源却是不需要手动释放的，这样在两种资源处理方式上的割裂会导致即使开发者足够有经验，也可能写出内存泄漏代码，毕竟百密一疏，在所难免嘛。</p>
<h2 id="rust中raii的实现方式"><a class="header" href="#rust中raii的实现方式">Rust中RAII的实现方式</a></h2>
<p>准确来说，Rust是一门基于所有权来管理资源（Ownership-based Resource Management）的语言，根据Rust的所有权模型，所有堆上的对象都有一个栈上的owner，当栈上的owner离开作用域时，它的析构器（destructor）会自动运行，清除堆上的对象和对象持有的资源（如果有的话），这其实就是RAII的思想。</p>
<p>在Rust中，第二、第三类资源的析构都是通过<a href="https://doc.rust-lang.org/nightly/std/ops/trait.Drop.html"><code>Drop</code></a>特性实现的，比如：</p>
<ul>
<li>智能指针<a href="https://doc.rust-lang.org/nightly/std/ops/trait.Drop.html"><code>Box</code></a>属于第二类资源，由于实现了<code>Drop</code>特性，当栈上的owner离开scope时，owner所指向的堆上内存也会同时释放（这也是为什么称之为智能指针的原因）。</li>
<li>标准库里<a href="https://doc.rust-lang.org/nightly/std/fs/struct.File.html"><code>File</code></a>属于第三类资源，由于实现了<code>Drop</code>特性，当栈上的owner离开scope时，文件的句柄（fd/handle）和锁（如果有）也会被关闭掉。</li>
</ul>
<p>也就是说，只要合理地实现<code>Drop</code>特性（大部分是lib作者的工作），编译器就会在编译期间自动插入相应的代码来实现二、三类资源的自动释放，避免资源泄漏问题，做到<strong>Write once, and off you go</strong>.</p>
<p>另外需要注意的一点，资源的释放不一定要在一个函数作用域结束之后（栈帧被销毁时）才被释放，在Rust中有多种方法可以提前结束一个资源的生命周期：</p>
<pre><pre class="playground"><code class="language-rust">// drop.rs

fn main() {
    m1();
    m2();
    m3();
}

struct S(i32);

impl Drop for S {
    fn drop(&amp;mut self) {
        println!(&quot;start dropping S{}.&quot;, self.0);
    }
}

// 方式一：主动调用`drop()`.
fn m1() {
    let s1 = S(1);

    drop(s1);

    println!(&quot;S1 has been dropped by explicitly calling `drop`.\n&quot;);
}

// 方式二：将`S` move到一个新的scope.
fn m2() {
    let s2 = S(2);

    { // move `s2` into this scope.
        s2;
    } // `s2` dropped here.

    println!(&quot;S2 has been dropped by moving it into a immediately-dropped scope.\n&quot;);
}

// 方式三：`S`构造完成后立即drop掉.
fn m3() {
    // Here we do not bind `S(3)` to any variable,
    // thus it gets dropped immediately, in place where it was initialized.
    let _ = S(3); // or just call `S(3);`

    println!(&quot;S3 has been dropped in place.\n&quot;);
}
</code></pre></pre>
<p>(Tip: 可以通过点击上面代码块右上角的运行按钮查看上面代码的运行结果)</p>
<h2 id="为什么gc语言没有实现raii"><a class="header" href="#为什么gc语言没有实现raii">为什么GC语言没有实现RAII</a></h2>
<p>个人认为主要是因为GC语言大多把对象分配在堆上，意味着没有像栈帧上的变量一样有一个清晰的scope和生命周期，无法把资源的释放逻辑和栈上对象绑定。同时，GC语言没有确定性析构的概念，GC什么时候回收堆上的对象完全是不确定的，也就意味着destructor什么时候被调用并不确定，这种不确定性对于一些系统资源（比如锁）来说是不能接受的。</p>
<blockquote>
<p>人生苦短，拥抱RAII。 --- Bjarne Stroustrup, God of C++</p>
</blockquote>
<h3 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://doc.rust-lang.org/stable/reference/memory-model.html">https://doc.rust-lang.org/stable/reference/memory-model.html</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding">https://en.wikipedia.org/wiki/Call_stack#Unwinding</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">5</sup>
<p><a href="https://doc.rust-lang.org/rust-by-example/scope/raii.html">https://doc.rust-lang.org/rust-by-example/scope/raii.html</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">6</sup>
<p><a href="https://doc.rust-lang.org/nomicon/unwinding.html">https://doc.rust-lang.org/nomicon/unwinding.html</a></p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">7</sup>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/rust-to-system-essence-raii.html">https://rustmagazine.github.io/rust_magazine_2021/chapter_4/rust-to-system-essence-raii.html</a></p>
</div>
<h1 id="零成本抽象"><a class="header" href="#零成本抽象">零成本抽象</a></h1>
<h1 id="所有权与借用"><a class="header" href="#所有权与借用">所有权与借用</a></h1>
<h1 id="result与panic"><a class="header" href="#result与panic">Result与Panic</a></h1>
<p><a href="http://joeduffyblog.com/2016/02/07/the-error-model/">http://joeduffyblog.com/2016/02/07/the-error-model/</a></p>
<h1 id="tcpip协议栈"><a class="header" href="#tcpip协议栈">TCP/IP协议栈</a></h1>
<p><strong>TCP/IP</strong>网络协议并不只是TCP、IP，它是<strong>一系列通用的网络协议</strong>的总称，这些网络协议一般自顶向下可划分为以下4层（也有其他划分方法）：</p>
<ul>
<li><strong>应用层</strong>（Applicaiton Layer）：负责为用户提供应用功能，不关心数据如何传输。应用层工作在用户态，而其他层都工作在内核态。</li>
<li><strong>传输层</strong>（Transport Layer）：为应用层提供网络支持，负责对报文进行重组和分组，并以TCP或UDP协议格式封装报文。</li>
<li><strong>网络层</strong>（Internet Layer）：负责路由以及将传输层的报文封装成IP报文发送给目标设备。</li>
<li><strong>链路层</strong>（Data Link Layer）：为网络层提供跨网络的数据传输服务。</li>
</ul>
<h2 id="术语表"><a class="header" href="#术语表">术语表</a></h2>
<p><strong>MAC</strong>：媒体访问控制地址（Media Access Control Address），用于在网络中唯一标识一个网卡。</p>
<p><strong>端口号</strong>（Port）：用16bit来识别主机上的程序/服务的（传输层）标识。Linux上的<code>/etc/services</code>文件记录了端口号映射。</p>
<h1 id="http协议"><a class="header" href="#http协议">HTTP协议</a></h1>
<p><strong>HTTP</strong>是⼀个专门在<strong>两点</strong>之间<strong>传输</strong>⽂字、图⽚、⾳频、视频等<strong>超⽂本数据</strong>的<strong>约定和规范</strong>。</p>
<h2 id="常见的状态码"><a class="header" href="#常见的状态码">常见的状态码</a></h2>
<table><thead><tr><th>状态码</th><th align="center">类别</th><th>描述</th></tr></thead><tbody>
<tr><td>1xx</td><td align="center">info</td><td>提示信息，表示目前处于中间状态</td></tr>
<tr><td>200 OK</td><td align="center">success</td><td>表示一切正常，返回的响应头会有body数据(HEAD请求除外)</td></tr>
<tr><td>204 No Content</td><td align="center">success</td><td>和200 OK基本相同，但响应头没有body数据</td></tr>
<tr><td>206 Partial Content</td><td align="center">success</td><td>用于分块下载和断点续传，表示返回的body数据只是一部分</td></tr>
<tr><td>301 Moved Permanently</td><td align="center">redirect</td><td>表示永久重定向，说明请求的资源不存在了，需要改用新的URL再次访问</td></tr>
<tr><td>302 Found</td><td align="center">redirect</td><td>表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL访问</td></tr>
<tr><td>304 Not Modified</td><td align="center">redirect</td><td>表示缓存重定向，表示资源未修改，重定向已存在的缓冲⽂件，用于缓存控制</td></tr>
<tr><td>400 Bad Request</td><td align="center">client error</td><td>表示客户端请求的报⽂有错误，但只是个笼统的错误</td></tr>
<tr><td>403 Forbidden</td><td align="center">client error</td><td>表示服务器禁⽌访问资源，并不是客户端的请求出错</td></tr>
<tr><td>404 Not Found</td><td align="center">client error</td><td>表示请求的资源在服务器上不存在或未找到</td></tr>
<tr><td>500 Internal Server Error</td><td align="center">server error</td><td>和400类似，是一个笼统的错误码</td></tr>
<tr><td>501 Not Implemented</td><td align="center">server error</td><td>表示客户端请求的功能还不⽀持</td></tr>
<tr><td>502 Bad Gateway</td><td align="center">server error</td><td>网关/代理服务器返回的错误码，表示自身正常，但访问后端服务器发生了错误</td></tr>
<tr><td>503 Service Unavailable</td><td align="center">server error</td><td>表示服务器当前很忙，暂时⽆法响应服务器</td></tr>
</tbody></table>
<h1 id="systemd"><a class="header" href="#systemd">systemd</a></h1>
<p>systemd是一个Linux系统基础组件的集合，提供了一个系统和服务管理器，运行为PID 1并负责启动其它程序<sup class="footnote-reference"><a href="#1">1</a></sup>。systemd目前已成为大部分Linux发行版的标准配置，可用以下命令验证当前系统是否使用systemd：</p>
<pre><code class="language-bash"># 第一行有systemd的话表示pid 1为systemd
ps -A | grep systemd
</code></pre>
<h2 id="unit"><a class="header" href="#unit">Unit</a></h2>
<p>systemd将系统资源统称为<strong>Unit</strong>，并划分为以下12种类型：</p>
<table><thead><tr><th>UNIT TYPE</th><th>DESCRIPTION</th></tr></thead><tbody>
<tr><td>service</td><td>系统服务</td></tr>
<tr><td>target</td><td>多个unit构成的一个组</td></tr>
<tr><td>device</td><td>硬件设备</td></tr>
<tr><td>mount</td><td>文件系统的挂载点</td></tr>
<tr><td>automount</td><td>自动挂载点</td></tr>
<tr><td>path</td><td>文件路径</td></tr>
<tr><td>scope</td><td>不是由systemd启动的外部进程</td></tr>
<tr><td>slice</td><td>进程组</td></tr>
<tr><td>snapshot</td><td>systemd快照</td></tr>
<tr><td>socket</td><td>用于进程间通信的socket</td></tr>
<tr><td>swap</td><td>swap文件</td></tr>
<tr><td>timer</td><td>定时器</td></tr>
</tbody></table>
<p>使用<code>systemctl list-units</code>命令可查看正在运行的Unit（不带参数），每个Unit都以<code>.TYPE</code>结尾以标识其类型。常用的用法还有：</p>
<pre><code class="language-bash"># 列出所有Unit
systemctl list-units --all
</code></pre>
<pre><code class="language-bash"># 列出所有没有运行的Unit
systemctl list-units --all --state=inactive
</code></pre>
<pre><code class="language-bash"># 列出所有加载失败的Unit
systemctl list-units --failed
</code></pre>
<pre><code class="language-bash"># 列出正在运行的指定类型的Unit，这里指定类型为`service`
systemctl list-units --type=service
</code></pre>
<p>使用<code>systemctl status</code>命令可查看系统状态（不带参数）和指定Unit的状态。</p>
<pre><code class="language-bash"># 查看sshd服务的状态
systemctl status sshd.service
</code></pre>
<p>使用systemctl命令时通常需要使用包括扩展名的单元全称（例如<code>sshd.service</code>），但在以下情形下可使用简写形式：</p>
<ul>
<li>如果无扩展名，systemctl默认扩展名为<code>.service</code>，例如<code>sshd</code>和<code>sshd.service</code>是等价的。</li>
<li>挂载点会自动转化为相应的<code>.mount</code>单元，例如<code>/home</code>和<code>home.mount</code>是等价的。</li>
<li>设备会自动转化为相应的<code>.device</code>单元，例如<code>/dev/sda2</code>和<code>dev-sda2.device</code>是等价的。</li>
</ul>
<h2 id="unit管理"><a class="header" href="#unit管理">Unit管理</a></h2>
<p>以下的命令用于控制一个Unit的运行状态，注意这些命令都需要sudo权限：</p>
<pre><code class="language-bash"># 启动一个服务
sudo systemctl start redis.service

# 停止一个服务
sudo systemctl stop redis.service

# 重启一个服务
sudo systemctl restart redis.service

# 杀死一个服务的所有进程，适用于stop命令无响应的情形
sudo systemctl kill redis.service
</code></pre>
<h2 id="unit配置文件"><a class="header" href="#unit配置文件">Unit配置文件</a></h2>
<p>systemd默认从<code>/etc/systemd/system/</code>目录读取Unit配置文件，里面大部分为符号链接，真正的配置文件存放在<code>/usr/lib/systemd/system/</code>目录下。</p>
<p>可用<code>systemctl enable</code>和<code>systemctl disable</code>两个命令在上面两个目录之间创建、断开符号链接（直接用ln命令也Ok）：</p>
<pre><code class="language-bash"># 创建符号链接
sudo systemctl enable redis.service

# 断开符号链接
sudo systemctl disable redis.service
</code></pre>
<p><code>systemctl list-unit-files</code>命令可查看所有配置文件，<code>systemctl cat unit.service</code>命令可查看指定Unit的具体配置。</p>
<p>如果修改了配置文件，需要让systemd重新加载配置文件，然后重新启动，否则修改不会生效。</p>
<pre><code class="language-bash"># 这里假设修改了redis服务的配置
sudo systemctl daemon-reload
sudo systemctl restart redis.service
</code></pre>
<blockquote>
<p>详细的配置文档可从<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">这里</a>找到。</p>
</blockquote>
<h2 id="一个简单的echo服务"><a class="header" href="#一个简单的echo服务">一个简单的echo服务</a></h2>
<pre><code class="language-text">[Unit]
Description=Testing-purposed echo service
After=network.target sshd.service
Wants=sshd.service
Requires=network.target

[Service]
ExecStartPre=-/bin/bash -c &quot;echo start echo service&quot;
ExecStartPre=-/bin/bash -c &quot;echo start echoing&quot;
ExecStart=/bin/bash -c &quot;for (( i=1; i&lt;=5; i++ )) ; do echo 42 &amp;&amp; sleep 1s ; done&quot;
ExecStartPost=-/bin/bash -c &quot;echo before or after 42&quot;
ExecStop=-/bin/bash -c &quot;echo stop echo service&quot;
ExecReload=/bin/bash -c &quot;for (( i=1; i&lt;=5; i++ )) ; do echo 42 &amp;&amp; sleep 1s ; done&quot;
Type=idle
Restart=always
RestartSec=5s

[Install]
WantedBy=multi-user.target
</code></pre>
<p>这里我们通过以上一个简单的echo服务来说明常见配置项的用法。我们可以看到，Unit配置文件分为三个区块：</p>
<ul>
<li><code>[Unit]</code>：定义不依赖于Unit类型的通用信息。</li>
<li><code>[Service]</code>：定义如何启动该服务，不是service类型的Unit无该区块。</li>
<li><code>[Install]</code>：定义如何安装这个配置文件，即怎样做到开机启动。</li>
</ul>
<p>每个字段的含义如下，注意所有Unit配置文件中的所有字段都是case-sensitive的：</p>
<ul>
<li><code>[Description]</code>：对当前服务的简单描述，这里定义的描述可通过<code>systemctl status unit</code>、<code>systemctl list-units</code>等命令看到</li>
<li><code>[After]</code>：定义应该在哪些Unit之后启动，这里表示echo服务需要在<code>network.target</code>和<code>sshd.target</code>之后启动；相应的，有一个<code>Before</code>字段定义该Unit应该在哪些Unit之前启动</li>
<li><code>[Wants]</code>：定义弱依赖关系，这里表示即使终端断开了，<code>echo</code>服务也会继续运行</li>
<li><code>[Requires]</code>：定义强依赖关系，这里表示如果网络服务中断了，<code>echo</code>服务也必须退出</li>
<li><code>[ExecStartPre]</code>：启动服务之前执行的命令；命令之前的<code>-</code>表示抑制错误，即即使发生错误，也不会影响其他命令的执行</li>
<li><code>[ExecStart]</code>：启动服务时执行的命令。作为<code>Service</code>块中最关键的命令，该字段必须设置。</li>
<li><code>[ExecStartPost]</code>：启动服务之后执行的命令</li>
<li><code>[ExecReload]</code>：重启服务时执行的命令</li>
<li><code>[ExecStop]</code>：停止服务时执行的命令</li>
<li><code>[Type]</code>：定义启动类型，可以设置的值如下：
<ul>
<li><code>simple</code>（默认值）：ExecStart字段启动的进程为主进程</li>
<li><code>forking</code>：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程</li>
<li><code>oneshot</code>：类似于simple，但只执行一次，systemd会等待它执行完，才启动其他服务</li>
<li><code>dbus</code>：类似于simple，但会等待收到D-Bus信号后启动</li>
<li><code>notify</code>：类似于simple，启动结束后会发出通知信号，然后systemd再启动其他服务</li>
<li><code>idle</code>：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li>
</ul>
</li>
<li><code>[Restart]</code>：定义systemd重启该服务的方式，可以设置的值如下：
<ul>
<li><code>no</code>（默认值）：退出后不会重启</li>
<li><code>on-success</code>：只有正常退出时（退出状态码为0），才会重启</li>
<li><code>on-failure</code>：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li>
<li><code>on-abnormal</code>：只有被信号终止和超时，才会重启</li>
<li><code>on-abort</code>：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li><code>on-watchdog</code>：超时退出，才会重启</li>
<li><code>always</code>：不管是什么退出原因，总是重启</li>
</ul>
</li>
<li><code>[RestartSec]</code>：表示systemd重启该服务之前，需要等待多少秒</li>
<li><code>[WantedBy]</code>：表示该服务所在的Target，在运行<code>systemctl enable echo.service</code>时，<code>echo.service</code>的符号链接会在<code>/etc/systemd/system/</code>下的<code>multi-user.target.wants</code>子目录中。常用的Target有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code></li>
</ul>
<p>接下来我们将<code>echo</code>服务部署到机器上，看看是否能正常运行。</p>
<p>首先，在<code>/usr/lib/systemd/system/</code>目录下创建一个<code>echo.service</code>文件：</p>
<pre><code class="language-bash">sudo vi /usr/lib/systemd/system/echo.service
</code></pre>
<p>然后将上面的<code>echo.service</code>配置复制进去，保存退出后执行以下命令加载配置：</p>
<pre><code class="language-bash">sudo systemctl enable echo
</code></pre>
<p>加载完成后，执行以下命令启动echo服务：</p>
<pre><code class="language-bash">sudo systemctl start echo
</code></pre>
<p>然后使用<code>journalctl</code>命令查看实时的输出：</p>
<pre><code class="language-bash">sudo journalctl -fu echo
</code></pre>
<p>测试完成后，用以下命令彻底清除测试用的echo服务：</p>
<pre><code class="language-bash">sudo systemctl disable echo
sudo rm /usr/lib/systemd/system/echo.service
systemctl daemon-reload
systemctl reset-failed
</code></pre>
<h3 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="httpssystemd://wiki.archlinux.org/title/">https://wiki.archlinux.org/title/systemd</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p><a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">https://www.freedesktop.org/software/systemd/man/systemd.unit.html</a></p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-113141331-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
